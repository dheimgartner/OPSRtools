\documentclass[a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{RJournal}
\usepackage{amsmath,amssymb,array}
\usepackage{booktabs}

%% load any required packages FOLLOWING this line
\usepackage{framed}
\usepackage{orcidlink}

%% custom commands
% \let\proglang=\textsf taken from jss.cls
\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\class}[1]{`\code{#1}'}
\newcommand{\fct}[1]{\code{#1()}}

\SweaveOpts{engine=R, eps=FALSE, keep.source = TRUE}
<<preliminaries, echo=FALSE, results=hide>>=
library("OPSRtools")
library("OPSR")

colvec <- c("#4c5760","#ff8811","#48a9a6")

options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
@

<<cache, echo=FALSE>>=
cache <- readRDS("./cache.rds")
fit <- cache$fit
fit_10 <- cache$fit_10
fit_aic <- cache$fit_aic
kfold <- cache$kfold
kfold_10 <- cache$kfold_10
kfold_aic <- cache$kfold_aic
@

%\VignetteIndexEntry{paper title}
%\VignetteDepends{packages (usually the ones you load with library() here)}
%\VignetteKeywords{keywords}
%\VignettePackage{OPSRtools}

\begin{document}

%% do not edit, for illustration only
\sectionhead{Contributed research article}
\volume{XX}
\volnumber{YY}
\year{20ZZ}
\month{AAAA}

\begin{article}

\title{\pkg{OPSRtools}: Estimation and Post-Estimation Routines for the \pkg{OPSR} Package}
\author{by Daniel Heimgartner \orcidlink{0000-0002-0643-8690}}

\maketitle

\abstract{
An abstract of less than 150 words. Shortly mention what \pkg{OPSR} does and what \pkg{OPSRtools} brings to the table (and why separated). \pkg{OPSRtools} helps the modeler during model selection (\fct{opsr\_select}), to cross-validate (\fct{opsr\_kfold}), to compute treatment effects (\fct{opsr\_ate}) and to visualize the key insights from a model (\fct{pairs}). \code{print} methods for the various underlying objects allow the analyst to easily grasp the object's key information.
}

\section{Introduction}

\section{Illustrations}

\begin{leftbar}
\begin{itemize}
\item Write about weighted paired $t$~test.
\item Write about weights being automatically used (e.g., in \fct{opsr\_ate})
\item \fct{opsr\_ate} prepares the data returning an object of class \class{opsr.ate} and \fct{summary.opsr.ate} performs main computations on this data, in particular weighted paired $t$~test. \fct{print.summary.opsr.ate} presents the results.
\end{itemize}
\end{leftbar}

Let us revisit the full model from \citet{Heimgartner+Axhausen:2025}, modeling telework adoption and weekly kilometers traveled. Telework adoption was differentiated into three segments: no telework (NTW), non-usual telework (NUTW, <3 days/week) and usual telework (UTW, 3+ days/week). The data is attached, documented (\code{?timeuse}) and can be loaded by
%
<<data>>=
data("timeuse", package = "OPSRtools")
@
%
Using \pkg{OPSR}'s functionality, the model can be estimated by
%
<<full-model, results=hide>>=
f <- wfh | log_weekly_km ~ wfh_allowed + teleworkability + start_tracking +
  log_commute_km + age + dogs + driverlicense + educ_higher + fixed_workplace +
  grocery_shopper + hh_income + hh_size + isco_clerical + isco_craft +
  isco_managers + isco_plant + isco_professionals + isco_service + isco_agri +
  isco_tech + married + n_children + freq_onl_order + parking_home +
  parking_work + permanent_employed + rents_home + res_loc + sex_male +
  shift_work + swiss + vacation + workload + young_kids |
  start_tracking + log_commute_km + age + dogs + driverlicense + educ_higher +
  fixed_workplace + grocery_shopper + hh_income + hh_size + married +
  n_children + freq_onl_order + parking_home + parking_work +
  permanent_employed + rents_home + res_loc + sex_male + shift_work + swiss +
  vacation + workload + young_kids |
  start_tracking + log_commute_km + age +
  dogs + driverlicense + educ_higher + fixed_workplace + grocery_shopper +
  hh_income + hh_size + married + n_children + freq_onl_order + parking_home +
  parking_work + permanent_employed + rents_home + res_loc + sex_male +
  shift_work + swiss + vacation + workload + young_kids |
  start_tracking + log_commute_km + age + dogs + driverlicense + educ_higher +
  fixed_workplace + grocery_shopper + hh_income + hh_size + married +
  n_children + freq_onl_order + parking_work + permanent_employed + rents_home +
  res_loc + sex_male + swiss + vacation + workload + young_kids

fit <- opsr(f, data = timeuse, weights = timeuse$weight)
@
%
This model is likely to be over-specified and as a usual first step, the analyst starts by excluding insignificant variables (below some threshold). Given the above formula object with many terms/variables, this process can be tedious or even error prone - boring at best. The function \fct{opsr\_step} allows the modeler to do this automatically. For example, excluding all variables which are not significant at the 10\% level
%
<<opsr-step>>=
fit_10 <- opsr_step(fit, pval = 0.1, printLevel = 0)
summary(fit_10)
@
%
where \code{printLevel = 0} is passed to \fct{opsr} and avoids printing working information during maximum likelihood estimation.

While this model (\code{fit\_10}) has considerably fewer parameters than \code{fit}, it is not necessarily the ``best'' model. To more rigorously sparsify the model and carefully evaulate each intermediate model, the function \fct{opsr\_select} can be used
%
<<opsr-select, eval=FALSE>>=
fit_aic <- opsr_select(fit, loss = "aic", printLevel = 0)
@
%
where \code{"aic"} specifies that the model selection is based on AIC. Other available options are \code{"bic"} for BIC and \code{"lrt"} for a likelihood ratio test. The above call yields an object of class \class{opsr.select} which can be printed to provide more information about the selection process (and elimination history, which is omitted here for brevity)
%
<<print-opsr-select>>=
print(fit_aic, print.elim.hist = FALSE)
@
%
where we see, that the final model (after the sixth iteration) has improved AIC by 49 points.

The three models can be compared by
%
<<anova>>=
print(anova(fit_10, fit_aic, fit), print.formula = FALSE)
@
%
where the likelihood ratio test would select the full model. However, the full model is likely over-fitting the data (in particular for the usual teleworkers, UTWers). To further investigate the out-of-sample performance, k-fold cross-validation can be performed
%
<<opsr-kfold, eval=FALSE>>=
## TODO
## remove cache again on final run
kfold <- opsr_kfold(fit, k = 10, printLevel = 0)
kfold_10 <- opsr_kfold(fit_10, k = 10, verbose = FALSE, printLevel = 0)
kfold_aic <- opsr_kfold(fit_aic, k = 10, verbose = FALSE, printLevel = 0)
@
%
The resulting object of class \class{opsr.kfold} is somewhat nested: It contains for each fold different out-of-sample loss computations

\begin{itemize}
\item \code{z}:
\end{itemize}

\pkg{OPSRtools} provides an extract method to collect the desired information
%
<<extract>>=
ll_mean <- kfold["ll_mean"]
ll_mean <- Reduce(rbind, ll_mean)
rownames(ll_mean) <- NULL
ll_mean
@
%
The three cross-validation objects can be plotted against each other
<<kfplot, eval=FALSE>>=
plot.it <- function(...) {
  op <- par(no.readonly = TRUE)
  on.exit(par(op))
  par(mfrow = c(2, 2))
  par(...)
  what <- c("ll_mean", "ll_p_mean", "r2")
  main <- c("Total", "Selection", "Outcome")
  for (i in seq_along(what)) {
    kfplot(list(kfold_10, kfold_aic, kfold), i = what[i], col = colvec,
           main = main[i])
    legend("bottomleft", legend = c("fit_10", "fit_aic", "fit"), fill = colvec,
           title = "Model", title.font = 2, bty = "n")
  }
}
plot.it()
@
%
where we see (Figure~\ref{fig:kfplot}), that \code{fit\_10} has negligible higher $R^2$ values for the UTWers but generally performs slightly worse than the other two models.

\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\centering
<<plot-kfplot, echo=FALSE, fig=TRUE, height=8, width=7.5>>=
<<kfplot>>
@
\caption{\label{fig:kfplot} Model comparison by k-fold cross-validation.}
\end{figure}

\begin{leftbar}
How can $R^2$ be negative???
\end{leftbar}

Having selected an appropriate model (say, in the name of Occam's razor \code{fit\_10}) the analyst would like to investigate treatment effects. This can be done by
%
<<opsr-ate>>=
ate <- opsr_ate(fit_10, type = "unlog-response")
print(ate)
@
%
where we needed to specify \code{type = "unlog-response"} (which is passed to \fct{predict.opsr}) since the outcome variable was log transformed (log weekly kilometers traveled). The significance values are based on a weighted paired t-test (performed via a regression in \fct{summyr.opsr.ate}).

The treatment effects can be visually summarised by a call to \fct{pairs}
%
<<pairs, eval=FALSE>>=
pairs(ate)
@
%
Figure~\ref{fig:pairs} presents all potential counterfactual outcomes. The diagonal depicts distributions in any given treatment regime and separate by the current (factual) treatment group. The weighted mean values are shown as red numbers. The lower triangular panels compare the model-implied (predicted) outcomes of two treatment regimes again separate by current treatment group. The red line indicates the 45-degree line of equal outcomes while the red squares depict again the weighted mean values. The upper triangular panels show (weighted) average treatment effects.

\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\centering
<<plot-pairs, echo=FALSE, fig=TRUE, height=7.5, width=7.5>>=
pairs(ate, labels.diag = c("NTWing", "NUTWing", "UTWing"), col = colvec,
  labels.reg = c("NTWers", "NUTWers", "UTWers"), cex = 1.75, cex.labels = 2,
  font.labels = 2,lwd.dens = 2.5, lty.diag = 4, xlim = c(0, 1000),
  ylim = c(0, 1000))
@
\caption{\label{fig:pairs} Pairs plot: Comparison of conditional expectations (weekly km traveled) by telework status in the lower panel. Corresponding distributions on the diagonal. Average treatment effects in the upper panel.}
\end{figure}

We clearly see, that the large error correlation ``rho3'' inflates (counterfactual) weekly kilometers traveled of the NTWers and NUTWers when adopting UTWing.

\begin{leftbar}
Find reference of unstable results Loshkin?
\end{leftbar}

\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\centering
<<heckman-correction, echo=FALSE, fig=TRUE, height=7.5, width=7>>=

## TODO
## add legend and text to the right of legend (similar to pairs)
## clean code below

heckman_ij <- function(fit, i, j) {
  imr <- predict(fit, type = "mills", group = i, counterfact = j)
  rho_j <- coef(fit)[[paste0("rho", j)]]
  sigma_j <- coef(fit)[[paste0("sigma", j)]]
  rho_j * sigma_j * imr
}

xb_ij <- function(fit, i, j) {
  xb <- predict(fit, type = "Xb", group = i, counterfact = j)
  xb
}

plot.it <- function() {
  op <- par(no.readonly = TRUE)
  on.exit(par(op))
  par(mfrow = c(3, 3))

  group <- c("NTWers", "NUTWers", "UTWers")
  counterfact <- c("NTWing", "NUTWing", "UTWing")

  for (i in 1:3) {
    for (j in 1:3) {
      h1 <- heckman_ij(fit_10, i, j)
      x1 <- xb_ij(fit_10, i, j)
      h2 <- heckman_ij(fit_aic, i, j)
      x2 <- xb_ij(fit_aic, i, j)
      plot(h1, x1, xlim = c(-0.5, 0.5), ylim = c(3, 7),
           col = scales::alpha(colvec[1], 0.3), pch = 19,
           xlab = expression(rho[j]*sigma[j]*IMR), ylab = expression(X*beta),
           main = paste(group[i], counterfact[j]))
      points(h2, x2, col = scales::alpha(colvec[2], 0.3), pch = 19)
      mh1 <- mean(h1, na.rm = TRUE)
      mx1 <- mean(x1, na.rm = TRUE)
      mh2 <- mean(h2, na.rm = TRUE)
      mx2 <- mean(x2, na.rm = TRUE)
      abline(v = mh1, col = colvec[1], lty = 2, lwd = 2)
      abline(h = mx1, col = colvec[1], lty = 2, lwd = 2)
      abline(v = mh2, col = colvec[2], lty = 2, lwd = 2)
      abline(h = mx2, col = colvec[2], lty = 2, lwd = 2)
      legend("bottomleft", legend = round(mh1 / mx1, 3), text.col = colvec[1], bty = "n")
      legend("bottomright", legend = round(mh2 / mx2, 3), text.col = colvec[2], bty = "n")
    }
  }
}

plot.it()
@
\caption{\label{fig:heckman-correction} Plotting the Heckman correction term against the linear predictor. The ratio of the two mean values is printed in red. Scales are shared across the facets.}
\end{figure}

\section{Summary}

\begin{leftbar}
This file is only a basic article template. For full details of \emph{The R Journal} style and information on how to prepare your article for submission, see the \href{https://journal.r-project.org/share/author-guide.pdf}{Instructions for Authors}.
\end{leftbar}

\section*{Computational details}

The results in this paper were obtained using
\proglang{R}~\Sexpr{paste(R.Version()[6:7], collapse = ".")} \citep{R} with the packages \pkg{OPSR}~\Sexpr{packageVersion("OPSR")} and ... \proglang{R} itself
and all packages used are available from the Comprehensive
\proglang{R} Archive Network (CRAN) at
\url{https://CRAN.R-project.org/}.

\bibliography{RJreferences}

\address{Daniel Heimgartner\\
  Institute for Transport Planning and Systems\\
  Eidgen\"ossische Technische Hochschule Z\"urich\\
  IFW C 46.1\\
  Haldeneggsteig 4\\
  8092 Z\"urich, Switzerland\\
  \orcidlink{0000-0002-0643-8690} 0000-0002-0643-8690\\
  \email{daniel.heimgartner@ivt.baug.ethz.ch}}

\end{article}

\end{document}
